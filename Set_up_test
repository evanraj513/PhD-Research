#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 28 16:32:58 2020

@author: evanraj
"""

import os
import sys

import numpy as np
from mpl_toolkits import mplot3d
import matplotlib.pyplot as plt
from matplotlib import cm
plt.rcParams['backend'] = "Qt4Agg"

l_path = '..'
m_path = os.path.abspath(l_path)
if not os.path.exists(m_path):
    print('Error importing modules. Need to specify new path')
    raise Exception
else:
    sys.path.append(m_path)

import numpy as np
import scipy as sp
from scipy.sparse import csr_matrix

from Research import ferro_system1
Ferro_sys = ferro_system1.Ferro_sys

### Parameters (global)
mu0 = 1.25667e-6
eps = 0.88422e-11
gamma = 2.2e5
K = 0
alpha = 0.2
H_s_guess = 10**5

### Parameters (system)
max_x = 16.4
disc = [0.4, 0.4, 0.4]

dt = 5e-10
T = 6e-8

if (max_x/disc[0])%2 == 0:
    print('Warning. Grid could fail, untested')
    size = round(max_x/disc[0])
    
elif (max_x/disc[0])%2 == 1:
    size = round(max_x/disc[0])
    
else:
    print('That domain and disc not available'
          '\n','Attempting closest available disc.')
    max_x = max_x - (max_x/disc[0])%2
    size = round(max_x/disc[0])


def sizing(nx):
    size_Ex = np.array([(nx-1)/2, (nx+1)/2, (nx+1)/2])
    size_Ey = np.array([(nx+1)/2, (nx-1)/2, (nx+1)/2])
    size_Ez = np.array([(nx+1)/2, (nx+1)/2, (nx-1)/2])

#    size_Bx = np.array([(nx-3)/2, (nx-1)/2, (nx-1)/2])
#    size_By = np.array([(nx-1)/2, (nx-3)/2, (nx-1)/2])
#    size_Bz = np.array([(nx-1)/2, (nx-1)/2, (nx-3)/2])
    
    size_Bx = np.array([(nx+1)/2, (nx-1)/2, (nx-1)/2])
    size_By = np.array([(nx-1)/2, (nx+1)/2, (nx-1)/2])
    size_Bz = np.array([(nx-1)/2, (nx-1)/2, (nx+1)/2])
    return [size_Ex, size_Ey, size_Ez, size_Bx, size_By, size_Bz]

## To give number of nodes
a = np.array(sizing(size)).prod(axis=1)

### Initial conditions
E0_x = np.zeros(shape = (int(a[0]),1))
E0_y = np.zeros(shape = (int(a[1]),1))
E0_z = np.zeros(shape = (int(a[2]),1))
E0 = np.concatenate((E0_x, E0_y, E0_z),axis=1).T

B0_x = np.zeros(shape = (int(a[3]),1))
B0_y = np.zeros(shape = (int(a[4]),1))
B0_z = np.zeros(shape = (int(a[5]),1))
B0 = np.concatenate((B0_x, B0_y, B0_z),axis=1).T

M0_x = np.zeros(shape = (int(a[3]),1))
M0_y = np.zeros(shape = (int(a[4]),1))
M0_z = 100*np.ones(shape = (int(a[5]),1)) 
M0 = np.concatenate((M0_x, M0_y, M0_z),axis=1).T

H0_x = np.zeros(shape = (int(a[3]),1))
H0_y = np.zeros(shape = (int(a[4]),1))
H0_z = np.zeros(shape = (int(a[5]),1))
H0 = np.concatenate((H0_x, H0_y, H0_z),axis=1).T

H_s_x = np.zeros(shape = (int(a[3]),1))
H_s_y = np.zeros(shape = (int(a[4]),1))
H_s_z = np.zeros(shape = (int(a[5]),1))
H_s = np.concatenate((H_s_x, H_s_y, H_s_z),axis=1).T

R_sys = Ferro_sys(size,disc,E0,H0,M0,H_s)
R_sys.set_up()

E_old = R_sys.E_old
H_old = R_sys.H_old
M_old = R_sys.M_old
B_old = R_sys.B_old

b_ind = R_sys.bound_ind

R_sys = Ferro_sys(size,disc,E0,H0,M0,H_s)
R_sys.dt = dt

def f_x(x,y,z,t):
    if t < 0.2:
        val = 0
    if x == 0 or x == max_x:
        val = 0
    else:
        val = 0
    
    return val

def f_y(x,y,z,t):
    
    val = 0
    if y == 0 or y == max_x:
        val = 0
    
    return val

def f_z(x,y,z,t):
    val = 0
    
    if z == 0 or z == max_x:
        val = 0
    
    return val

R_sys.fx = f_x
R_sys.fy = f_y
R_sys.fz = f_z

### Testing dot product
t = dt

F = np.concatenate((R_sys.Fx(t), R_sys.Fy(t), R_sys.Fz(t)), axis=1)
E_new_values = E_old.values + dt*H_old.curl()

#Setting all E boundaries to 0
for j in b_ind[0]:
    E_new_values[0][j] = 0
for k in b_ind[1]:
    E_new_values[1][k] = 0
for l in b_ind[2]:
    E_new_values[2][l] = 0

#Forcing term and boundary conditions inside F
E_new_values = E_new_values+F.T
R_sys.E_new = E_new_values

B_new_values = B_old.values - dt*R_sys.E_new.curl()
R_sys.B_new = B_new_values

B_on = (B_old.values + B_new_values)/2

f = 2*M_old.values
a = -(abs(gamma)*dt/2)*(B_on/mu0 + R_sys.H_s.values) - alpha*M_old.values

bdp = R_sys.better_dot_pdt


### Testing E_curl shape, specifically last column
##x = E_old.x
##y = E_old.y
#
### Looks good, had to change my sizing, and there was an indexing error
#
### Debugging single run
#
## b_ind looks correct
#
## error in setting values, not in computation (at least for compiling)
## May be the dimensions, as the shape is now (3,48,1), the 1 might be the issue
##   Ans: Error came from using size instead of shape. Size multiplies each of the   
##       dimemsions. That's all. 
## There was an issue with storing F as a numpy array of three lil_matrix, 
## So I just made them numpy arrays all. 
#
## So now there is an issue with computing M_new, going to debug this piece by piece. 
##   Ans: The issue was within the dot product, because I have a 3D array, it was weird. 
##       Just did it piecewise
#
#mu0 = 10.0 
#eps = 1.0
#gamma = 1.0
#K = 0
#alpha = 1.0
#
#B_on = B_old.values
#
#f = 2*M_old.values
#a = -(abs(gamma)*dt/2)*(B_on/mu0 + test1.H_s.values) - alpha*M_old.values
#
#x = H_old.x
#y = H_old.y
#z = H_old.z
#
#dx = 0.1
#dy = 0.1
#dz = 0.1
#
#ind = z.myind_std


#fig = plt.figure()
#ax = plt.axes(projection='3d')
#E_old = R_sys.E_old
#
#x1 = np.zeros(shape = (E_old.x.value.shape[0],1))
#y1 = np.zeros(shape = (E_old.x.value.shape[0],1))
#z1 = np.zeros(shape = (E_old.x.value.shape[0],1))
#
#for k in np.arange(0,E_old.x.value.shape[0]):
#    x1[k] = R_sys.ind_rev_x_out(k)[0]
#    y1[k] = R_sys.ind_rev_x_out(k)[1]
#    z1[k] = E_old.x.value[k]
#
#x,y = np.meshgrid(x1,y1)
#z = z1
#
#surf = ax.plot_surface(x, y, z) ## This will plot where size gives value

#fig = plt.figure()
#ax = fig.add_subplot(111, projection='3d')
#E_old = R_sys.E_old
#
#x1 = np.zeros(shape = (E_old.x.nx*E_old.x.ny,1))
#y1 = np.copy(x1)
#z1 = np.copy(x1)
#
#for k in np.arange(0,x1.shape[0]):
#    x1[k] = R_sys.ind_rev_x_out(k)[0]
#    y1[k] = R_sys.ind_rev_x_out(k)[1]
#    z1[k] = E_old.x.value[k]
#
#
#plt.show()


# Now debugging the secant method. Let's find out if I got it right

#M_old, B_old, B_new, H_s = R_sys.M_old, R_sys.B_old, R_sys.B_new, R_sys.H_s
#
#val = np.zeros(shape = M_old.values.shape)
#
#M_new_values = val
#        
#M_on = (M_new_values + M_old.values)/2
#B_on = (B_old.values + B_new.values)/2
#
#if type(val) != np.ndarray:
#    print('Error, function cannot be evaluated for this input. Abort')
#    raise Exception
#    
#elif val.shape != M_old.values.shape:
#    print('Error in input size. Abort')
#    raise Exception
#
#a =1/dt*(M_new_values - M_old.values)
#b = abs(gamma)*( (1/mu_0)*B_on - M_on + K*P*M_on)
#
#bt = np.cross(a = b,b = M_on)
#
#c = alpha/np.norm(M_on) * M_on
#ct = np.cross(c, a)
#
#
### Debugging saving into pandas DataFrame
#
#t1 = OrderedDict()
#
#t1['E.x'] = R_sys.E_old.values[0].T[0]
#
#t1
#Out[78]: OrderedDict([('E.x', array([1., 1., 1., ..., 0., 0., 0.]))])
#
#t2 = pd.DataFrame(t1)

















