#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb  4 18:30:34 2020

@author: evanraj
"""

import os
import sys
from datetime import date

today1 = date.today()
today = today1.strftime("%d_%m_%y")

import numpy as np
from mpl_toolkits import mplot3d
import matplotlib.pyplot as plt
from matplotlib import cm
plt.rcParams['backend'] = "Qt4Agg"
from collections import OrderedDict
import pandas as pd

l_path = '..'
m_path = os.path.abspath(l_path)
if not os.path.exists(m_path):
    print('Error importing modules. Need to specify new path')
    raise Exception
else:
    sys.path.append(m_path)

#import numpy as np
#import scipy as sp
#from scipy.sparse import csr_matrix

from Research import ferro_system1
Ferro_sys = ferro_system1.Ferro_sys

### Parameters (global)
mu0 = 1.25667e-6
eps = 0.88422e-11
gamma = 2.2e5
K = 0
alpha = 0.2
H_s_val = 10**5

### Parameters (system)
max_x = 16.4
disc = [0.4, 0.4, 0.4]

dt = 5e-10
T = 6e-8

if (max_x/disc[0])%2 == 0:
    print('Warning. Grid could fail, untested')
    size = round(max_x/disc[0])
    
elif (max_x/disc[0])%2 == 1:
    size = round(max_x/disc[0])
    
else:
    print('That domain and disc not available'
          '\n','Attempting closest available disc.')
    max_x = max_x - (max_x/disc[0])%2
    size = round(max_x/disc[0])
    
def sizing(nx):
    size_Ex = np.array([(nx-1)/2, (nx+1)/2, (nx+1)/2])
    size_Ey = np.array([(nx+1)/2, (nx-1)/2, (nx+1)/2])
    size_Ez = np.array([(nx+1)/2, (nx+1)/2, (nx-1)/2])

#    size_Bx = np.array([(nx-3)/2, (nx-1)/2, (nx-1)/2])
#    size_By = np.array([(nx-1)/2, (nx-3)/2, (nx-1)/2])
#    size_Bz = np.array([(nx-1)/2, (nx-1)/2, (nx-3)/2])
    
    size_Bx = np.array([(nx+1)/2, (nx-1)/2, (nx-1)/2])
    size_By = np.array([(nx-1)/2, (nx+1)/2, (nx-1)/2])
    size_Bz = np.array([(nx-1)/2, (nx-1)/2, (nx+1)/2])
    return [size_Ex, size_Ey, size_Ez, size_Bx, size_By, size_Bz]

### Initial conditions

# To give number of nodes
a = np.round(np.array(sizing(size)).prod(axis=1))

### Initial conditions
E0_x = np.zeros(shape = (int(a[0]),1))
E0_y = np.zeros(shape = (int(a[1]),1))
E0_z = np.zeros(shape = (int(a[2]),1))
E0 = np.concatenate((E0_x, E0_y, E0_z),axis=1).T

B0_x = np.zeros(shape = (int(a[3]),1))
B0_y = np.zeros(shape = (int(a[4]),1))
B0_z = np.zeros(shape = (int(a[5]),1))
B0 = np.concatenate((B0_x, B0_y, B0_z),axis=1).T

M0_x = np.zeros(shape = (int(a[3]),1))
M0_y = np.zeros(shape = (int(a[4]),1))
M0_z = 100*np.ones(shape = (int(a[5]),1)) 
M0 = np.concatenate((M0_x, M0_y, M0_z),axis=1).T

H0_x = np.zeros(shape = (int(a[3]),1))
H0_y = np.zeros(shape = (int(a[4]),1))
H0_z = np.zeros(shape = (int(a[5]),1))
H0 = np.concatenate((H0_x, H0_y, H0_z),axis=1).T

H_s_x = H_s_val*np.ones(shape = (int(a[3]),1))
H_s_y = H_s_val*np.ones(shape = (int(a[4]),1))
H_s_z = H_s_val*np.ones(shape = (int(a[5]),1))
H_s = np.concatenate((H_s_x, H_s_y, H_s_z),axis=1).T

R_sys = Ferro_sys(size,disc,E0,H0,M0,H_s)
R_sys.dt = dt

#def f_x(x,y,z,t):
#    if t < 0.2:
#        val = 0
#    if x == 0 or x == max_x:
#        val = 0
#    else:
#        val = 0
#    
#    return val
#
#def f_y(x,y,z,t):
#    
#    val = 0
#    if y == 0 or y == max_x:
#        val = 0
#    
#    return val
#
#def f_z(x,y,z,t):
#    val = 0
#    
#    if z == 0 or z == max_x:
#        val = 0
#    
#    return val

#### Ricker Pulse parameters
beta0 = 4E4
f = 4E7
a = 1.34
k = (np.pi/a)**2
c = 3E8

def g(x):
    '''
    Actual Ricker pulse function
    '''
    if x < a:
        pa = 2*k/11*(2*k*(x-a)**2-1)
        pb = (np.e**(-k*(x-a)**2))
        
        return pa*pb

def f_x(x,y,z,t):
    '''
    Ricker Pulse for x
    '''
    if y < 1E-12: #approx 0
        d = beta0*g(t-x/c)*f
        return d
    else:
        return 0
    
    
    
def f_y(x,y,z,t):
    '''
    Ricker Pulse for y
    '''
    return 0
    
    
def f_z(x,y,z,t):
    '''
    Ricker Pulse for z
    '''
    return 0

R_sys.fx = f_x
R_sys.fy = f_y
R_sys.fz = f_z

for t in np.arange(dt,T,dt):
    ### re-initializing the system
    R_sys.set_up()
    
    ### Running the system
    R_sys.single_run(t)
    
    ## Updating old fields
    R_sys.E_old2 = R_sys.E_old.values
    R_sys.B_old2 = R_sys.B_old.values
    R_sys.M_old2 = R_sys.M_old.values
    R_sys.H_old2 = R_sys.H_old.values
    
    R_sys.E_old = R_sys.E_new.values
    R_sys.H_old = R_sys.H_new.values
    R_sys.M_old = R_sys.M_new.values
    R_sys.B_old = R_sys.B_new.values
    
    print('Current time: ', '{:.2e}'.format(t))

## Plotting stuff

fig_Mz = R_sys.plot_slice('M','z',10)
fig_Bz = R_sys.plot_slice('B','z',10)
fig_Ez = R_sys.plot_slice('E','z',10)
fig_Hz = R_sys.plot_slice('H','z',10)

def mkdir_p(mypath):
    '''Creates a directory. equivalent to using mkdir -p on the command line'''

    from errno import EEXIST
    from os import makedirs,path

    try:
        makedirs(mypath)
    except OSError as exc: 
        if exc.errno == EEXIST and path.isdir(mypath):
            pass
        else: raise

mkdir_p(today)

## Saving data
name = 'test1'

R_sys.save_data(today+'/'+name)

    # Run parameters
        #Global Parameters
data = OrderedDict()
data['mu0'] = mu0
data['eps'] = eps 
data['gamma'] = gamma
data['K'] = K
data['alpha'] = alpha
data['H_s'] = H_s_val

        # Parameters (system)
data['max_x'] = max_x
data['disc'] = disc[0]
data['size'] = size
data['T'] = T
data['dt'] = dt

df = pd.DataFrame([data])
df.to_csv(today+'/'+name+'_param.csv')

fig_Mz.savefig(today+'/'+name+'Mz_10')
fig_Bz.savefig(today+'/'+name+'Bz_10')
fig_Ez.savefig(today+'/'+name+'Ez_10')
fig_Hz.savefig(today+'/'+name+'Hz_10')

def det_E_M():
    '''
    Determines the vector of error_moduli for a given system
    as described in running notes 2/13
    '''
    M = R_sys.M_old.values
    
    E_M = abs(np.linalg.norm(M,axis=0) - np.linalg.norm(M0,axis=0))/(np.linalg.norm(M0,axis=0))
    
    return E_M
    



